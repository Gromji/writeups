

# This file was *autogenerated* from the file Small_Inscription.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_30 = Integer(30); _sage_const_256 = Integer(256); _sage_const_0 = Integer(0)#!/usr/bin/sage

from Crypto.Util.number import *

msg_base = b'There is something reeeally important you should know, the flag is '

e = _sage_const_3  # Given public key
ct = # Given ciphertext
N = # Given N

# Iterate over length of message
for i in range(_sage_const_1 , _sage_const_30 ):
    msg_guess = bytes_to_long(msg_base) * pow(_sage_const_256 , i)

    PR = PolynomialRing(Zmod(N), names=('x',)); (x,) = PR._first_ngens(1)# Construct a polynomial ring

    # This code has been written according to the documentation of small_roots function in SageMath
    # ct === (msg_guess + x0)^e (mod N) so we want to find root of f(x) = (msg_guess + x)^e (mod N) 
    # now our goal is to find a root for f(x) === 0 (mod N)
    f = (msg_guess + x)**e - ct 		       
    
    # Try to find a small root for it using Coppersmith method (which uses LLL)
    # Default values for this function seem to work fine			   
    root = f.small_roots() 
    
    if len(root) != _sage_const_0 :
        msg = int(msg_guess + root[_sage_const_0 ])
        break

msg_decoded = long_to_bytes(msg).decode()

print(msg_decoded)

